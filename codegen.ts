/*
 * Created by aimozg on 18.06.2017.
 * Confidential until published on GitHub
 */

function writeSources(files:TFile[]): string[] {
	const sources         = [] as string[];
	let tabs              = '';
	let blockDepth        = 0;
	let eol = true;
	
	function as3(loc: string): number {
		sources.push(tabs + loc);
		return sources.length - 1;
	}
	
	function logcode(loc: string): void {
		Logger.log(':' + sources.length + ' <' + blockDepth + '>\t' + loc);
	}
	function markNotEol():void {
		eol = false;
	}
	function as3log(loc: string): void {
		if (!eol) {
			sources[sources.length-1] += loc;
			logcode(loc);
			eol = true;
		} else {
			sources.push(tabs + loc);
			logcode(loc);
		}
	}
	
	function indentPlus(): void {
		tabs += '\t';
	}
	
	function indentMinus(): void {
		tabs     = tabs.substring(1);
	}
	
	function writeComment(comment: string): void {
		comment = comment.trim();
		if (comment.indexOf('\n')<0) {
			as3('// '+comment);
		} else {
			as3('/*');
			for (let l of comment.split('\n')) as3(' * ' + l);
			as3('*/');
		}
		
	}
	interface WritingContext {
		bold:boolean;
		italic:boolean;
		output:string;
		depth:number;
	}
	function appendOutput(ctx:WritingContext,text:string):void {
		ctx.output += text;
	}
	function flushFormat(ctx: WritingContext, bold2: boolean, italic2: boolean): void {
		if (ctx.bold && !bold2 && ctx.italic) {
			// in case of   <b> xx <i> yy ^ </b> zz </i>
			// replace with <b> xx <i> yy </i> ^ </b> <i> zz </i>
			ctx.italic = false;
			ctx.output += '</i>';
		}
		if (!ctx.bold && bold2) ctx.output += '<b>';
		if (!ctx.italic && italic2) ctx.output += '<i>';
		if (ctx.italic && !italic2) ctx.output += '</i>';
		if (ctx.bold && !bold2) ctx.output += '</b>';
		ctx.bold   = bold2;
		ctx.italic = italic2;
	}
	function flushOutput(ctx:WritingContext):void {
		let s = ctx.output;
		let s2 = '';
		while (s) {
			let i = 0;
			while (s[i]=='\n')i++;
			i=s.indexOf('\n',i);
			if (i < 0 || i == s.length-1) {
				break;
			} else {
				if (s2) as3('outputText(' + JSON.stringify(s2) + ');');
				s2 = s.substring(0,i);
				s = s.substring(i);
			}
		}
		s += s2;
		if (s) {
			as3('outputText(' + JSON.stringify(s) + ');');
		}
		ctx.output = '';
	}
	function closeContext(ctx:WritingContext):void {
		flushOutput(ctx);
		flushFormat(ctx,false,false);
	}
	function writeStatement(ctx: WritingContext, stmt: TStatement):void {
		Logger.log('<'+ctx.depth+'>\t'+stmt.type+' '+JSON.stringify(stmt.run?stmt.run.text.substr(0,10):null));
		if (stmt.type == 'text' || stmt.type == 'tag') {
			let text = stmt.run.text;
			if (text) {
				flushFormat(ctx, stmt.run.bold, stmt.run.italic);
				appendOutput(ctx,text);
			}
		} else {
			closeContext(ctx);
		}
		switch(stmt.type) {
			case 'text':
			case 'tag':
				break;
			case 'comment':
				writeComment(stmt.comment);
				break;
			case 'button':
				as3log('addButton('+stmt.idx+', '+JSON.stringify(stmt.label)+', '+stmt.action+');');
				break;
			case 'call':
				as3log(stmt.action+'();');
				break;
			case 'exec':
				as3log(stmt.action+';');
				break;
			case 'if':
				as3log('if ('+stmt.condition+') {');
				indentPlus();
				ctx.depth++;
				for (let istmt of stmt.thenBlock) {
					writeStatement(ctx, istmt);
				}
				closeContext(ctx);
				ctx.depth--;
				indentMinus();
				as3log('}');
				if (stmt.elseIfBlock) {
					markNotEol();
					as3log(' else ');
					markNotEol();
					writeStatement(ctx, stmt.elseIfBlock);
				} else if (stmt.elseBlock) {
					markNotEol();
					as3log(' else {');
					ctx.depth++;
					indentPlus();
					for (let istmt of stmt.elseBlock) {
						writeStatement(ctx, istmt);
					}
					closeContext(ctx);
					as3log('}');
				}
				break;
			default:
				writeComment("// [ERROR] Unknown stmt type "+stmt['type']);
		}
	}
	
	for (let file of files) {
		tabs = '';
		as3('// Start of file "' + file.name + '"');
		as3('// GENERATED CODE - MANUAL CHANGES MAY BE OVERWRITTEN');
		as3('// Generated by Lewd Writer\'s Assistant for Google Docs');
		as3('// Source: ' + (file.document.getUrl() || file.document.getId()));
		as3('package ' + file.path.join('.') + ' {');
		as3('');
		as3('import classes.*');
		as3('');
		if (file.comment) writeComment(file.comment);
		as3('public class ' + file.classname + ' extends ' + file.superclass + ' {');
		indentPlus();
		// todo write config
		for (let method of file.methods) {
			as3('');
			if (method.comment) writeComment(method.comment);
			as3('public function ' + method.name + '():void {');
			indentPlus();
			as3('clearOutput();');
			as3('menu();');
			// todo write method content
			let ctx:WritingContext = {
				bold:false,italic:false,output:'',depth:1
			};
			for (let stmt of method.statements) {
				writeStatement(ctx, stmt);
			}
			closeContext(ctx);
			indentMinus();
			as3('}');
		}
		indentMinus();
		as3('}');
		as3('}');
		as3('// End of file "' + file.name + '"');
	}
	as3('');
	return sources;
}
